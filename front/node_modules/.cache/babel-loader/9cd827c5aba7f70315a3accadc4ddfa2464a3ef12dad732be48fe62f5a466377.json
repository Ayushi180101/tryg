{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CdpHTTPRequest = void 0;\nconst HTTPRequest_js_1 = require(\"../api/HTTPRequest.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst assert_js_1 = require(\"../util/assert.js\");\n/**\n * @internal\n */\nclass CdpHTTPRequest extends HTTPRequest_js_1.HTTPRequest {\n  id;\n  #client;\n  #isNavigationRequest;\n  #allowInterception;\n  #interceptionHandled = false;\n  #url;\n  #resourceType;\n  #method;\n  #hasPostData = false;\n  #postData;\n  #headers = {};\n  #frame;\n  #continueRequestOverrides;\n  #responseForRequest = null;\n  #abortErrorReason = null;\n  #interceptResolutionState = {\n    action: HTTPRequest_js_1.InterceptResolutionAction.None\n  };\n  #interceptHandlers;\n  #initiator;\n  get client() {\n    return this.#client;\n  }\n  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {\n    super();\n    this.#client = client;\n    this.id = data.requestId;\n    this.#isNavigationRequest = data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase();\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#hasPostData = data.request.hasPostData ?? false;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n  url() {\n    return this.#url;\n  }\n  continueRequestOverrides() {\n    (0, assert_js_1.assert)(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n  responseForRequest() {\n    (0, assert_js_1.assert)(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n  abortErrorReason() {\n    (0, assert_js_1.assert)(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n  interceptResolutionState() {\n    if (!this.#allowInterception) {\n      return {\n        action: HTTPRequest_js_1.InterceptResolutionAction.Disabled\n      };\n    }\n    if (this.#interceptionHandled) {\n      return {\n        action: HTTPRequest_js_1.InterceptResolutionAction.AlreadyHandled\n      };\n    }\n    return {\n      ...this.#interceptResolutionState\n    };\n  }\n  isInterceptResolutionHandled() {\n    return this.#interceptionHandled;\n  }\n  enqueueInterceptAction(pendingHandler) {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n  async finalizeInterceptions() {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {\n      action\n    } = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this.#respond(this.#responseForRequest);\n      case 'continue':\n        return await this.#continue(this.#continueRequestOverrides);\n    }\n  }\n  resourceType() {\n    return this.#resourceType;\n  }\n  method() {\n    return this.#method;\n  }\n  postData() {\n    return this.#postData;\n  }\n  hasPostData() {\n    return this.#hasPostData;\n  }\n  async fetchPostData() {\n    try {\n      const result = await this.#client.send('Network.getRequestPostData', {\n        requestId: this.id\n      });\n      return result.postData;\n    } catch (err) {\n      (0, util_js_1.debugError)(err);\n      return;\n    }\n  }\n  headers() {\n    return this.#headers;\n  }\n  response() {\n    return this._response;\n  }\n  frame() {\n    return this.#frame;\n  }\n  isNavigationRequest() {\n    return this.#isNavigationRequest;\n  }\n  initiator() {\n    return this.#initiator;\n  }\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  failure() {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText\n    };\n  }\n  async continue(overrides = {}, priority) {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    (0, assert_js_1.assert)(this.#allowInterception, 'Request Interception is not enabled!');\n    (0, assert_js_1.assert)(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: HTTPRequest_js_1.InterceptResolutionAction.Continue,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort' || this.#interceptResolutionState.action === 'respond') {\n        return;\n      }\n      this.#interceptResolutionState.action = HTTPRequest_js_1.InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n  async #continue(overrides = {}) {\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this.#interceptionHandled = true;\n    const postDataBinaryBase64 = postData ? Buffer.from(postData).toString('base64') : undefined;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');\n    }\n    await this.#client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData: postDataBinaryBase64,\n      headers: headers ? (0, HTTPRequest_js_1.headersArray)(headers) : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async respond(response, priority) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    (0, assert_js_1.assert)(this.#allowInterception, 'Request Interception is not enabled!');\n    (0, assert_js_1.assert)(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: HTTPRequest_js_1.InterceptResolutionAction.Respond,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = HTTPRequest_js_1.InterceptResolutionAction.Respond;\n    }\n  }\n  async #respond(response) {\n    this.#interceptionHandled = true;\n    const responseBody = response.body && (0, util_js_1.isString)(response.body) ? Buffer.from(response.body) : response.body || null;\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map(item => {\n          return String(item);\n        }) : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n    }\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');\n    }\n    await this.#client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: status,\n      responsePhrase: HTTPRequest_js_1.STATUS_TEXTS[status],\n      responseHeaders: (0, HTTPRequest_js_1.headersArray)(responseHeaders),\n      body: responseBody ? responseBody.toString('base64') : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async abort(errorCode = 'failed', priority) {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    (0, assert_js_1.assert)(errorReason, 'Unknown error code: ' + errorCode);\n    (0, assert_js_1.assert)(this.#allowInterception, 'Request Interception is not enabled!');\n    (0, assert_js_1.assert)(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (this.#interceptResolutionState.priority === undefined || priority >= this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: HTTPRequest_js_1.InterceptResolutionAction.Abort,\n        priority\n      };\n      return;\n    }\n  }\n  async #abort(errorReason) {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');\n    }\n    await this.#client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason: errorReason || 'Failed'\n    }).catch(handleError);\n  }\n}\nexports.CdpHTTPRequest = CdpHTTPRequest;\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\nasync function handleError(error) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  (0, util_js_1.debugError)(error);\n}","map":{"version":3,"names":["HTTPRequest_js_1","require","util_js_1","assert_js_1","CdpHTTPRequest","HTTPRequest","id","client","isNavigationRequest","allowInterception","interceptionHandled","url","resourceType","method","hasPostData","postData","headers","frame","continueRequestOverrides","responseForRequest","abortErrorReason","interceptResolutionState","action","InterceptResolutionAction","None","interceptHandlers","initiator","constructor","interceptionId","data","redirectChain","requestId","loaderId","type","_interceptionId","request","toLowerCase","_redirectChain","key","value","Object","entries","assert","Disabled","AlreadyHandled","isInterceptResolutionHandled","enqueueInterceptAction","pendingHandler","push","finalizeInterceptions","reduce","promiseChain","interceptAction","then","Promise","resolve","abort","Error","respond","continue","fetchPostData","result","send","err","debugError","response","_response","slice","failure","_failureText","errorText","overrides","priority","startsWith","undefined","Continue","#continue","postDataBinaryBase64","Buffer","from","toString","headersArray","catch","error","handleError","Respond","#respond","responseBody","body","isString","responseHeaders","header","keys","Array","isArray","map","item","String","contentType","byteLength","status","responseCode","responsePhrase","STATUS_TEXTS","errorCode","errorReason","errorReasons","Abort","#abort","exports","aborted","accessdenied","addressunreachable","blockedbyclient","blockedbyresponse","connectionaborted","connectionclosed","connectionfailed","connectionrefused","connectionreset","internetdisconnected","namenotresolved","timedout","failed","includes","originalMessage"],"sources":["C:\\Users\\PC\\tryg\\front\\node_modules\\puppeteer-core\\src\\cdp\\HTTPRequest.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Frame} from '../api/Frame.js';\nimport {\n  type ContinueRequestOverrides,\n  type ErrorCode,\n  headersArray,\n  HTTPRequest,\n  InterceptResolutionAction,\n  type InterceptResolutionState,\n  type ResourceType,\n  type ResponseForRequest,\n  STATUS_TEXTS,\n} from '../api/HTTPRequest.js';\nimport type {ProtocolError} from '../common/Errors.js';\nimport {debugError, isString} from '../common/util.js';\nimport {assert} from '../util/assert.js';\n\nimport type {CdpHTTPResponse} from './HTTPResponse.js';\n\n/**\n * @internal\n */\nexport class CdpHTTPRequest extends HTTPRequest {\n  override id: string;\n  declare _redirectChain: CdpHTTPRequest[];\n  declare _response: CdpHTTPResponse | null;\n\n  #client: CDPSession;\n  #isNavigationRequest: boolean;\n  #allowInterception: boolean;\n  #interceptionHandled = false;\n  #url: string;\n  #resourceType: ResourceType;\n\n  #method: string;\n  #hasPostData = false;\n  #postData?: string;\n  #headers: Record<string, string> = {};\n  #frame: Frame | null;\n  #continueRequestOverrides: ContinueRequestOverrides;\n  #responseForRequest: Partial<ResponseForRequest> | null = null;\n  #abortErrorReason: Protocol.Network.ErrorReason | null = null;\n  #interceptResolutionState: InterceptResolutionState = {\n    action: InterceptResolutionAction.None,\n  };\n  #interceptHandlers: Array<() => void | PromiseLike<any>>;\n  #initiator?: Protocol.Network.Initiator;\n\n  override get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    frame: Frame | null,\n    interceptionId: string | undefined,\n    allowInterception: boolean,\n    data: {\n      /**\n       * Request identifier.\n       */\n      requestId: Protocol.Network.RequestId;\n      /**\n       * Loader identifier. Empty string if the request is fetched from worker.\n       */\n      loaderId?: Protocol.Network.LoaderId;\n      /**\n       * URL of the document this request is loaded for.\n       */\n      documentURL?: string;\n      /**\n       * Request data.\n       */\n      request: Protocol.Network.Request;\n      /**\n       * Request initiator.\n       */\n      initiator?: Protocol.Network.Initiator;\n      /**\n       * Type of this resource.\n       */\n      type?: Protocol.Network.ResourceType;\n    },\n    redirectChain: CdpHTTPRequest[]\n  ) {\n    super();\n    this.#client = client;\n    this.id = data.requestId;\n    this.#isNavigationRequest =\n      data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase() as ResourceType;\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#hasPostData = data.request.hasPostData ?? false;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n\n  override url(): string {\n    return this.#url;\n  }\n\n  override continueRequestOverrides(): ContinueRequestOverrides {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n\n  override responseForRequest(): Partial<ResponseForRequest> | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n\n  override abortErrorReason(): Protocol.Network.ErrorReason | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n\n  override interceptResolutionState(): InterceptResolutionState {\n    if (!this.#allowInterception) {\n      return {action: InterceptResolutionAction.Disabled};\n    }\n    if (this.#interceptionHandled) {\n      return {action: InterceptResolutionAction.AlreadyHandled};\n    }\n    return {...this.#interceptResolutionState};\n  }\n\n  override isInterceptResolutionHandled(): boolean {\n    return this.#interceptionHandled;\n  }\n\n  enqueueInterceptAction(\n    pendingHandler: () => void | PromiseLike<unknown>\n  ): void {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n\n  override async finalizeInterceptions(): Promise<void> {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {action} = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this.#respond(this.#responseForRequest);\n      case 'continue':\n        return await this.#continue(this.#continueRequestOverrides);\n    }\n  }\n\n  override resourceType(): ResourceType {\n    return this.#resourceType;\n  }\n\n  override method(): string {\n    return this.#method;\n  }\n\n  override postData(): string | undefined {\n    return this.#postData;\n  }\n\n  override hasPostData(): boolean {\n    return this.#hasPostData;\n  }\n\n  override async fetchPostData(): Promise<string | undefined> {\n    try {\n      const result = await this.#client.send('Network.getRequestPostData', {\n        requestId: this.id,\n      });\n      return result.postData;\n    } catch (err) {\n      debugError(err);\n      return;\n    }\n  }\n\n  override headers(): Record<string, string> {\n    return this.#headers;\n  }\n\n  override response(): CdpHTTPResponse | null {\n    return this._response;\n  }\n\n  override frame(): Frame | null {\n    return this.#frame;\n  }\n\n  override isNavigationRequest(): boolean {\n    return this.#isNavigationRequest;\n  }\n\n  override initiator(): Protocol.Network.Initiator | undefined {\n    return this.#initiator;\n  }\n\n  override redirectChain(): CdpHTTPRequest[] {\n    return this._redirectChain.slice();\n  }\n\n  override failure(): {errorText: string} | null {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText,\n    };\n  }\n\n  override async continue(\n    overrides: ContinueRequestOverrides = {},\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (\n        this.#interceptResolutionState.action === 'abort' ||\n        this.#interceptResolutionState.action === 'respond'\n      ) {\n        return;\n      }\n      this.#interceptResolutionState.action =\n        InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n\n  async #continue(overrides: ContinueRequestOverrides = {}): Promise<void> {\n    const {url, method, postData, headers} = overrides;\n    this.#interceptionHandled = true;\n\n    const postDataBinaryBase64 = postData\n      ? Buffer.from(postData).toString('base64')\n      : undefined;\n\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.continueRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.continueRequest', {\n        requestId: this._interceptionId,\n        url,\n        method,\n        postData: postDataBinaryBase64,\n        headers: headers ? headersArray(headers) : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async respond(\n    response: Partial<ResponseForRequest>,\n    priority?: number\n  ): Promise<void> {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n\n  async #respond(response: Partial<ResponseForRequest>): Promise<void> {\n    this.#interceptionHandled = true;\n\n    const responseBody: Buffer | null =\n      response.body && isString(response.body)\n        ? Buffer.from(response.body)\n        : (response.body as Buffer) || null;\n\n    const responseHeaders: Record<string, string | string[]> = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n\n        responseHeaders[header.toLowerCase()] = Array.isArray(value)\n          ? value.map(item => {\n              return String(item);\n            })\n          : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(\n        Buffer.byteLength(responseBody)\n      );\n    }\n\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.fulfillRequest', {\n        requestId: this._interceptionId,\n        responseCode: status,\n        responsePhrase: STATUS_TEXTS[status],\n        responseHeaders: headersArray(responseHeaders),\n        body: responseBody ? responseBody.toString('base64') : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async abort(\n    errorCode: ErrorCode = 'failed',\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority >= this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority,\n      };\n      return;\n    }\n  }\n\n  async #abort(\n    errorReason: Protocol.Network.ErrorReason | null\n  ): Promise<void> {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.failRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.failRequest', {\n        requestId: this._interceptionId,\n        errorReason: errorReason || 'Failed',\n      })\n      .catch(handleError);\n  }\n}\n\nconst errorReasons: Record<ErrorCode, Protocol.Network.ErrorReason> = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed',\n} as const;\n\nasync function handleError(error: ProtocolError) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}